{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Go Utils Go Utils is a comprehensive Golang utilities library. The aim of this library is to offer high quality, performant and well tested utility functions using Go 1.18 Generics. Installation go get -u github.com/Goldziher/go-utils Why This Library? \ud83d\udcaf Rigorously Tested \ud83d\ude80 Highly Performant \ud83d\udc4d Typed Using Generics \u2705 Production Ready Contributing This project aims to be a community driven project. I'd like to encourage you to make suggestions, request features and contribute code.","title":"Welcome to Go Utils"},{"location":"#welcome-to-go-utils","text":"Go Utils is a comprehensive Golang utilities library. The aim of this library is to offer high quality, performant and well tested utility functions using Go 1.18 Generics.","title":"Welcome to Go Utils"},{"location":"#installation","text":"go get -u github.com/Goldziher/go-utils","title":"Installation"},{"location":"#why-this-library","text":"\ud83d\udcaf Rigorously Tested \ud83d\ude80 Highly Performant \ud83d\udc4d Typed Using Generics \u2705 Production Ready","title":"Why This Library?"},{"location":"#contributing","text":"This project aims to be a community driven project. I'd like to encourage you to make suggestions, request features and contribute code.","title":"Contributing"},{"location":"contributing/","text":"Contributing To contribute code changes or update the documentation, please follow these steps: Fork the upstream repository and clone the fork locally. Install pre-commit and install the hook by running pre-commit install Make whatever changes and additions you wish and commit these - please try to keep your commit history clean. Create a pull request to the main repository with an explanation of your changes Note: if you add new code or modify existing code - 100% test coverage is mandatory and tests should be well written.","title":"Contributing"},{"location":"contributing/#contributing","text":"To contribute code changes or update the documentation, please follow these steps: Fork the upstream repository and clone the fork locally. Install pre-commit and install the hook by running pre-commit install Make whatever changes and additions you wish and commit these - please try to keep your commit history clean. Create a pull request to the main repository with an explanation of your changes Note: if you add new code or modify existing code - 100% test coverage is mandatory and tests should be well written.","title":"Contributing"},{"location":"license/","text":"The MIT License (MIT) Copyright (c) 2022 Na'aman Hirschfeld Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"maputils/copy/","text":"Copy func Copy[K comparable, V any](mapInstance map[K]V) map[K]V Copy takes a map with keys K and values V and returns a copy. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/maputils\" ) func main () { vegetables := map [ string ] int { \"potatoes\" : 5 , \"carrots\" : 10 , } copiedVegetables := maputils . Copy ( vegetables ) copiedVegetables [ \"potatoes\" ] = 3 fmt . Print ( vegetables [ \"potatoes\" ]) // 5 fmt . Print ( copiedVegetables [ \"potatoes\" ]) // 3 }","title":"Copy"},{"location":"maputils/copy/#copy","text":"func Copy[K comparable, V any](mapInstance map[K]V) map[K]V Copy takes a map with keys K and values V and returns a copy. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/maputils\" ) func main () { vegetables := map [ string ] int { \"potatoes\" : 5 , \"carrots\" : 10 , } copiedVegetables := maputils . Copy ( vegetables ) copiedVegetables [ \"potatoes\" ] = 3 fmt . Print ( vegetables [ \"potatoes\" ]) // 5 fmt . Print ( copiedVegetables [ \"potatoes\" ]) // 3 }","title":"Copy"},{"location":"maputils/filter/","text":"Filter func Filter[K comparable, V any](mapInstance map[K]V, function func(key K, value V) bool) map[K]V Filter takes a map with keys K and values V, and executes the passed in function for each key-value pair. If the filter function returns true, the key-value pair will be included in the output, otherwise it is filtered out. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/maputils\" ) func main () { vegetables := map [ string ] int { \"potatoes\" : 5 , \"carrots\" : 10 , } result := maputils . Filter ( vegetables , func ( key string , value int ) bool { return value == 5 }) fmt . Print ( result ) // { \"potatoes\": 5 } }","title":"Filter"},{"location":"maputils/filter/#filter","text":"func Filter[K comparable, V any](mapInstance map[K]V, function func(key K, value V) bool) map[K]V Filter takes a map with keys K and values V, and executes the passed in function for each key-value pair. If the filter function returns true, the key-value pair will be included in the output, otherwise it is filtered out. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/maputils\" ) func main () { vegetables := map [ string ] int { \"potatoes\" : 5 , \"carrots\" : 10 , } result := maputils . Filter ( vegetables , func ( key string , value int ) bool { return value == 5 }) fmt . Print ( result ) // { \"potatoes\": 5 } }","title":"Filter"},{"location":"maputils/forEach/","text":"ForEach func ForEach[K comparable, V any](mapInstance map[K]V, function func(key K, value V)) ForEach given a map with keys K and values V, executes the passed in function for each key-value pair. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/maputils\" ) func main () { vegetables := map [ string ] int { \"potatoes\" : 5 , \"carrots\" : 10 , } maputils . ForEach ( vegetables , func ( key string , value int ) { fmt . Printf ( \"Buy %d Kg of %s\" , value , key ) // \"Buy 5 Kg of potatoes\", \"Buy 10 Kg of carrots\" }) }","title":"ForEach"},{"location":"maputils/forEach/#foreach","text":"func ForEach[K comparable, V any](mapInstance map[K]V, function func(key K, value V)) ForEach given a map with keys K and values V, executes the passed in function for each key-value pair. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/maputils\" ) func main () { vegetables := map [ string ] int { \"potatoes\" : 5 , \"carrots\" : 10 , } maputils . ForEach ( vegetables , func ( key string , value int ) { fmt . Printf ( \"Buy %d Kg of %s\" , value , key ) // \"Buy 5 Kg of potatoes\", \"Buy 10 Kg of carrots\" }) }","title":"ForEach"},{"location":"maputils/keys/","text":"Keys func Keys[K comparable, V any](mapInstance map[K]V) []K Keys takes a map with keys K and values V and returns a slice of type K with the map's keys. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/maputils\" ) func main () { vegetables := map [ string ] int { \"potatoes\" : 5 , \"carrots\" : 10 , } result := maputils . Keys ( vegetables ) fmt . Print ( result ) // [\"potatoes\", \"carrots\"] }","title":"Keys"},{"location":"maputils/keys/#keys","text":"func Keys[K comparable, V any](mapInstance map[K]V) []K Keys takes a map with keys K and values V and returns a slice of type K with the map's keys. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/maputils\" ) func main () { vegetables := map [ string ] int { \"potatoes\" : 5 , \"carrots\" : 10 , } result := maputils . Keys ( vegetables ) fmt . Print ( result ) // [\"potatoes\", \"carrots\"] }","title":"Keys"},{"location":"maputils/merge/","text":"Merge func Merge[K comparable, V any](mapInstances ...map[K]V) map[K]V Merge takes a variadic numbers of maps with keys K and values V and returns a merged map. Merging is done from left to right. If a key already exists in a previous map, its value is over-written. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/maputils\" ) func main () { vegetables := map [ string ] int { \"potatoes\" : 5 , \"carrots\" : 10 , \"tomatoes\" : 3 , } fruits := map [ string ] int { \"bananas\" : 3 , \"tomatoes\" : 5 , } result := maputils . Merge ( vegetables , fruits ) fmt . Print ( result ) //{ \"potatoes\": 5, \"carrots\": 10, \"tomatoes\": 5, \"bananas\": 3 } }","title":"Merge"},{"location":"maputils/merge/#merge","text":"func Merge[K comparable, V any](mapInstances ...map[K]V) map[K]V Merge takes a variadic numbers of maps with keys K and values V and returns a merged map. Merging is done from left to right. If a key already exists in a previous map, its value is over-written. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/maputils\" ) func main () { vegetables := map [ string ] int { \"potatoes\" : 5 , \"carrots\" : 10 , \"tomatoes\" : 3 , } fruits := map [ string ] int { \"bananas\" : 3 , \"tomatoes\" : 5 , } result := maputils . Merge ( vegetables , fruits ) fmt . Print ( result ) //{ \"potatoes\": 5, \"carrots\": 10, \"tomatoes\": 5, \"bananas\": 3 } }","title":"Merge"},{"location":"maputils/values/","text":"Values func Values[K comparable, V any](mapInstance map[K]V) []V Values takes a map with keys K and values V and returns a slice of type V with the map's values. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/maputils\" ) func main () { vegetables := map [ string ] int { \"potatoes\" : 5 , \"carrots\" : 10 , } result := maputils . Values ( vegetables ) fmt . Print ( result ) // [5, 10] }","title":"Values"},{"location":"maputils/values/#values","text":"func Values[K comparable, V any](mapInstance map[K]V) []V Values takes a map with keys K and values V and returns a slice of type V with the map's values. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/maputils\" ) func main () { vegetables := map [ string ] int { \"potatoes\" : 5 , \"carrots\" : 10 , } result := maputils . Values ( vegetables ) fmt . Print ( result ) // [5, 10] }","title":"Values"},{"location":"sliceutils/copy/","text":"Copy func Copy[T any](slice []T) []T Copy receives a slice of type T and returns a copy. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 } numeralsCopy := sliceutils . Copy ( numerals ) numeralsCopy [ 0 ] = 1 fmt . Print ( numerals ) // [0, 1] fmt . Print ( numeralsCopy ) // [1, 1] }","title":"Copy"},{"location":"sliceutils/copy/#copy","text":"func Copy[T any](slice []T) []T Copy receives a slice of type T and returns a copy. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 } numeralsCopy := sliceutils . Copy ( numerals ) numeralsCopy [ 0 ] = 1 fmt . Print ( numerals ) // [0, 1] fmt . Print ( numeralsCopy ) // [1, 1] }","title":"Copy"},{"location":"sliceutils/difference/","text":"Difference func Difference[T comparable](slices ...[]T) []T Difference takes a variadic number of slices of type T and returns a slice of type T containing the elements that are different between the slices. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { first , second := [] int { 1 , 2 , 3 }, [] int { 1 , 7 , 3 } result := sliceutils . Difference ( first , second ) fmt . Print ( result ) // [2, 7] }","title":"Difference"},{"location":"sliceutils/difference/#difference","text":"func Difference[T comparable](slices ...[]T) []T Difference takes a variadic number of slices of type T and returns a slice of type T containing the elements that are different between the slices. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { first , second := [] int { 1 , 2 , 3 }, [] int { 1 , 7 , 3 } result := sliceutils . Difference ( first , second ) fmt . Print ( result ) // [2, 7] }","title":"Difference"},{"location":"sliceutils/every/","text":"Every func Every[T any](slice []T, predicate func(value T, index int, slice []T) bool) bool Every takes a slice of type T and a predicate function, returning true if the predicate returned true for every elements. The function is passed the current element, the current index and the slice itself as function arguments. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { friends := [] string { \"John\" , \"Bob\" , \"Mendy\" , \"Suzy\" , \"John\" } result := sliceutils . Every ( friends , func ( value string , index int , slice [] string ) bool { return value == \"Mandy\" }) fmt . Print ( result ) // false }","title":"Every"},{"location":"sliceutils/every/#every","text":"func Every[T any](slice []T, predicate func(value T, index int, slice []T) bool) bool Every takes a slice of type T and a predicate function, returning true if the predicate returned true for every elements. The function is passed the current element, the current index and the slice itself as function arguments. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { friends := [] string { \"John\" , \"Bob\" , \"Mendy\" , \"Suzy\" , \"John\" } result := sliceutils . Every ( friends , func ( value string , index int , slice [] string ) bool { return value == \"Mandy\" }) fmt . Print ( result ) // false }","title":"Every"},{"location":"sliceutils/filter/","text":"Filter func Filter[T any](slice []T, predicate func(value T, index int, slice []T) bool) []T Filter takes a slice of type T and filters it using the given predicate function. The predicate is passed the current element, the current index and the slice as function arguments. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } oddNumbers := sliceutils . Filter ( numerals , func ( value int , index int , slice [] int ) bool { return value % 2 != 0 }) fmt . Printf ( \"%v\" , oddNumbers ) // [1 3 5 7 9] }","title":"Filter"},{"location":"sliceutils/filter/#filter","text":"func Filter[T any](slice []T, predicate func(value T, index int, slice []T) bool) []T Filter takes a slice of type T and filters it using the given predicate function. The predicate is passed the current element, the current index and the slice as function arguments. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } oddNumbers := sliceutils . Filter ( numerals , func ( value int , index int , slice [] int ) bool { return value % 2 != 0 }) fmt . Printf ( \"%v\" , oddNumbers ) // [1 3 5 7 9] }","title":"Filter"},{"location":"sliceutils/find/","text":"Find func Find[T any](slice []T, predicate func(value T, index int, slice []T) bool) *T Find takes a slice of type T and executes the passed in predicate function for each element in the slice. If the predicate returns true, a pointer to the element is returned. If no element is found, nil is returned. The function is passed the current element, the current index and the slice itself as function arguments. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { days := [] string { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" } result := sliceutils . Find ( days , func ( value string , index int , slice [] string ) bool { return strings . Contains ( value , \"Wed\" ) }) fmt . Print ( result ) // \"Wednesday\" }","title":"Find"},{"location":"sliceutils/find/#find","text":"func Find[T any](slice []T, predicate func(value T, index int, slice []T) bool) *T Find takes a slice of type T and executes the passed in predicate function for each element in the slice. If the predicate returns true, a pointer to the element is returned. If no element is found, nil is returned. The function is passed the current element, the current index and the slice itself as function arguments. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { days := [] string { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" } result := sliceutils . Find ( days , func ( value string , index int , slice [] string ) bool { return strings . Contains ( value , \"Wed\" ) }) fmt . Print ( result ) // \"Wednesday\" }","title":"Find"},{"location":"sliceutils/findIndex/","text":"FindIndex func FindIndex[T any](slice []T, predicate func(value T, index int, slice []T) bool) int FindIndex takes a slice of type T and executes the passed in predicate function for each element in the slice. If the predicate returns true, the element's index is returned. If no element is found, -1 is returned. The function is passed the current element, the current index and the slice itself as function arguments. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { days := [] string { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" } result := sliceutils . FindIndex ( days , func ( value string , index int , slice [] string ) bool { return strings . Contains ( value , \"Wed\" ) }) fmt . Print ( result ) // 3 }","title":"FindIndex"},{"location":"sliceutils/findIndex/#findindex","text":"func FindIndex[T any](slice []T, predicate func(value T, index int, slice []T) bool) int FindIndex takes a slice of type T and executes the passed in predicate function for each element in the slice. If the predicate returns true, the element's index is returned. If no element is found, -1 is returned. The function is passed the current element, the current index and the slice itself as function arguments. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { days := [] string { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" } result := sliceutils . FindIndex ( days , func ( value string , index int , slice [] string ) bool { return strings . Contains ( value , \"Wed\" ) }) fmt . Print ( result ) // 3 }","title":"FindIndex"},{"location":"sliceutils/findIndexOf/","text":"FindIndexOf func FindIndexOf[T comparable](slice []T, value T) int FindIndexOf takes a slice of type T and a value of type T. If any element in the slice equals the given value, its index is returned. If no element is found, -1 is returned. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { days := [] string { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" } result := sliceutils . FindIndexOf ( days , \"Wednesday\" ) fmt . Print ( result ) // 3 }","title":"FindIndexOf"},{"location":"sliceutils/findIndexOf/#findindexof","text":"func FindIndexOf[T comparable](slice []T, value T) int FindIndexOf takes a slice of type T and a value of type T. If any element in the slice equals the given value, its index is returned. If no element is found, -1 is returned. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { days := [] string { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" , \"Saturday\" } result := sliceutils . FindIndexOf ( days , \"Wednesday\" ) fmt . Print ( result ) // 3 }","title":"FindIndexOf"},{"location":"sliceutils/findIndexes/","text":"FindIndexes func FindIndexes[T any](slice []T, predicate func(value T, index int, slice []T) bool) []int FindIndexes takes a slice of type T and executes the passed in predicate function for each element in the slice, returning a slice containing all indexes for which the predicate returned true. The function is passed the current element, the current index and the slice itself as function arguments. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { friends := [] string { \"John\" , \"Bob\" , \"Mendy\" , \"Suzy\" , \"John\" } result := sliceutils . FindIndexes ( friends , func ( value string , index int , slice [] string ) bool { return value == \"John\" }) fmt . Print ( result ) // [0, 4] }","title":"FindIndexes"},{"location":"sliceutils/findIndexes/#findindexes","text":"func FindIndexes[T any](slice []T, predicate func(value T, index int, slice []T) bool) []int FindIndexes takes a slice of type T and executes the passed in predicate function for each element in the slice, returning a slice containing all indexes for which the predicate returned true. The function is passed the current element, the current index and the slice itself as function arguments. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { friends := [] string { \"John\" , \"Bob\" , \"Mendy\" , \"Suzy\" , \"John\" } result := sliceutils . FindIndexes ( friends , func ( value string , index int , slice [] string ) bool { return value == \"John\" }) fmt . Print ( result ) // [0, 4] }","title":"FindIndexes"},{"location":"sliceutils/findIndexesOf/","text":"FindIndexesOf func FindIndexes[T any](slice []T, predicate func(value T, index int, slice []T) bool) []int FindIndexesOf takes a slice of type T and a value of type T, returning a slice containing all indexes where elements equal the passed in value. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { friends := [] string { \"John\" , \"Bob\" , \"Mendy\" , \"Suzy\" , \"John\" } result := sliceutils . FindIndexesOf ( friends , \"John\" ) fmt . Print ( result ) // [0, 4] }","title":"FindIndexesOf"},{"location":"sliceutils/findIndexesOf/#findindexesof","text":"func FindIndexes[T any](slice []T, predicate func(value T, index int, slice []T) bool) []int FindIndexesOf takes a slice of type T and a value of type T, returning a slice containing all indexes where elements equal the passed in value. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { friends := [] string { \"John\" , \"Bob\" , \"Mendy\" , \"Suzy\" , \"John\" } result := sliceutils . FindIndexesOf ( friends , \"John\" ) fmt . Print ( result ) // [0, 4] }","title":"FindIndexesOf"},{"location":"sliceutils/findLastIndex/","text":"FindLastIndex func FindLastIndex[T any](slice []T, predicate func(value T, index int, slice []T) bool) int FindLastIndex takes a slice of type T and executes the passed in predicate function for each element in the slice starting from its end. If the predicate returns true, the element's index is returned. If no element is found, -1 is returned. The function is passed the current element, the current index and the slice itself as function arguments. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { friends := [] string { \"John\" , \"Bob\" , \"Mendy\" , \"Suzy\" , \"John\" } result := sliceutils . FindLastIndex ( friends , func ( value string , index int , slice [] string ) bool { return value == \"John\" }) fmt . Print ( result ) // 4 }","title":"FindLastIndex"},{"location":"sliceutils/findLastIndex/#findlastindex","text":"func FindLastIndex[T any](slice []T, predicate func(value T, index int, slice []T) bool) int FindLastIndex takes a slice of type T and executes the passed in predicate function for each element in the slice starting from its end. If the predicate returns true, the element's index is returned. If no element is found, -1 is returned. The function is passed the current element, the current index and the slice itself as function arguments. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { friends := [] string { \"John\" , \"Bob\" , \"Mendy\" , \"Suzy\" , \"John\" } result := sliceutils . FindLastIndex ( friends , func ( value string , index int , slice [] string ) bool { return value == \"John\" }) fmt . Print ( result ) // 4 }","title":"FindLastIndex"},{"location":"sliceutils/findLastIndexOf/","text":"FindLastIndexOf func FindLastIndexOf[T comparable](slice []T, value T) int FindLastIndexOf takes a slice of type T and a value of type T. If any element in the slice equals the given value, the last index of is occurrence is returned. If no element is found, -1 is returned. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { friends := [] string { \"John\" , \"Bob\" , \"Mendy\" , \"Suzy\" , \"John\" } result := sliceutils . FindLastIndexOf ( friends , \"John\" ) fmt . Print ( result ) // 4 }","title":"FindLastIndexOf"},{"location":"sliceutils/findLastIndexOf/#findlastindexof","text":"func FindLastIndexOf[T comparable](slice []T, value T) int FindLastIndexOf takes a slice of type T and a value of type T. If any element in the slice equals the given value, the last index of is occurrence is returned. If no element is found, -1 is returned. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { friends := [] string { \"John\" , \"Bob\" , \"Mendy\" , \"Suzy\" , \"John\" } result := sliceutils . FindLastIndexOf ( friends , \"John\" ) fmt . Print ( result ) // 4 }","title":"FindLastIndexOf"},{"location":"sliceutils/forEach/","text":"ForEach func ForEach[T any](slice []T, function func(value T, index int, slice []T)) ForEach executes the passed in function for each element in the given slice. The function is passed the current element, the current index and the slice as function arguments. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { result := 0 numerals := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } sliceutils . ForEach ( numerals , func ( value int , index int , slice [] int ) { result += value }) fmt . Print ( result ) // 45 }","title":"ForEach"},{"location":"sliceutils/forEach/#foreach","text":"func ForEach[T any](slice []T, function func(value T, index int, slice []T)) ForEach executes the passed in function for each element in the given slice. The function is passed the current element, the current index and the slice as function arguments. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { result := 0 numerals := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } sliceutils . ForEach ( numerals , func ( value int , index int , slice [] int ) { result += value }) fmt . Print ( result ) // 45 }","title":"ForEach"},{"location":"sliceutils/includes/","text":"Includes func Includes[T comparable](slice []T, value T) bool Includes receives a slice of type T and a value of type T, determining whether or not the value is included in the slice. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { friends := [] string { \"John\" , \"Bob\" , \"Mendy\" , \"Suzy\" , \"John\" } result := sliceutils . Includes ( friends , \"John\" ) fmt . Print ( result ) // true }","title":"Includes"},{"location":"sliceutils/includes/#includes","text":"func Includes[T comparable](slice []T, value T) bool Includes receives a slice of type T and a value of type T, determining whether or not the value is included in the slice. package main import ( \"fmt\" \"strings\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { friends := [] string { \"John\" , \"Bob\" , \"Mendy\" , \"Suzy\" , \"John\" } result := sliceutils . Includes ( friends , \"John\" ) fmt . Print ( result ) // true }","title":"Includes"},{"location":"sliceutils/insert/","text":"Insert func Insert[T any](slice []T, i int, value T) []T Insert takes a slice of type T, an index and a value of type T, inserting the value at the given index and shifting any existing elements to the right. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 2 } numerals = sliceutils . Insert ( numerals , 1 , 1 ) fmt . Print ( numerals ) // [0, 1, 2] }","title":"Insert"},{"location":"sliceutils/insert/#insert","text":"func Insert[T any](slice []T, i int, value T) []T Insert takes a slice of type T, an index and a value of type T, inserting the value at the given index and shifting any existing elements to the right. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 2 } numerals = sliceutils . Insert ( numerals , 1 , 1 ) fmt . Print ( numerals ) // [0, 1, 2] }","title":"Insert"},{"location":"sliceutils/intersection/","text":"Intersection func Intersection[T comparable](slices ...[]T) []T Intersection takes a variadic number of slices of type T and returns a slice of type T containing any values that are common to all slices. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { first , second := [] int { 1 , 2 , 3 }, [] int { 1 , 7 , 3 } result := sliceutils . Intersection ( first , second ) fmt . Print ( result ) // [1, 3] }","title":"Intersection"},{"location":"sliceutils/intersection/#intersection","text":"func Intersection[T comparable](slices ...[]T) []T Intersection takes a variadic number of slices of type T and returns a slice of type T containing any values that are common to all slices. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { first , second := [] int { 1 , 2 , 3 }, [] int { 1 , 7 , 3 } result := sliceutils . Intersection ( first , second ) fmt . Print ( result ) // [1, 3] }","title":"Intersection"},{"location":"sliceutils/map/","text":"Map func Map[T any, R any](slice []T, mapper func(value T, index int, slice []T) R) (mapped []R) Map allows transforming the values in a slice by executing the given mapper function for each element in the slice. The function is passed the current element, the current index and the slice itself as function arguments. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } result := sliceutils . Map ( numerals , func ( value int , index int , slice [] int ) int { return value * 2 }) fmt . Print ( result ) // [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] }","title":"Map"},{"location":"sliceutils/map/#map","text":"func Map[T any, R any](slice []T, mapper func(value T, index int, slice []T) R) (mapped []R) Map allows transforming the values in a slice by executing the given mapper function for each element in the slice. The function is passed the current element, the current index and the slice itself as function arguments. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } result := sliceutils . Map ( numerals , func ( value int , index int , slice [] int ) int { return value * 2 }) fmt . Print ( result ) // [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] }","title":"Map"},{"location":"sliceutils/merge/","text":"Merge func Merge[T any](slices ...[]T) (mergedSlice []T) Merge takes slices of type T and merges them into a single slice of type T, preserving their order. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { first := [] int { 1 , 2 , 3 } second := [] int { 4 , 5 , 6 } third := [] int { 7 , 8 , 9 } result := sliceutils . Merge ( first , second , third ) fmt . Print ( result ) // [1, 2, 3, 4, 5, 6, 7, 8, 9] }","title":"Merge"},{"location":"sliceutils/merge/#merge","text":"func Merge[T any](slices ...[]T) (mergedSlice []T) Merge takes slices of type T and merges them into a single slice of type T, preserving their order. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { first := [] int { 1 , 2 , 3 } second := [] int { 4 , 5 , 6 } third := [] int { 7 , 8 , 9 } result := sliceutils . Merge ( first , second , third ) fmt . Print ( result ) // [1, 2, 3, 4, 5, 6, 7, 8, 9] }","title":"Merge"},{"location":"sliceutils/reduce/","text":"Reduce func Reduce[T any, R any](slice []T, reducer func(acc R, value T, index int, slice []T) R, initial R) R Reduce allows transforming the slice and its values into a different value by executing the given reducer function for each element in the slice. The function is passed the accumulator, current element, current index and the slice as function arguments. The third argument to reduce is the initial value. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } sum := sliceutils . Reduce ( numerals , func ( acc int , cur int , index int , slice [] int ) int { return acc + cur }, 0 , ) fmt . Print ( sum ) // 45 }","title":"Reduce"},{"location":"sliceutils/reduce/#reduce","text":"func Reduce[T any, R any](slice []T, reducer func(acc R, value T, index int, slice []T) R, initial R) R Reduce allows transforming the slice and its values into a different value by executing the given reducer function for each element in the slice. The function is passed the accumulator, current element, current index and the slice as function arguments. The third argument to reduce is the initial value. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } sum := sliceutils . Reduce ( numerals , func ( acc int , cur int , index int , slice [] int ) int { return acc + cur }, 0 , ) fmt . Print ( sum ) // 45 }","title":"Reduce"},{"location":"sliceutils/remove/","text":"Remove func Remove[T any](slice []T, i int) []T Remove takes a slice of type T and an index, removing the element at the given index. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } numerals = sliceutils . Remove ( numerals , 3 ) fmt . Print ( numerals ) // [0, 1, 2, 4, 5, 6, 7, 8, 9] }","title":"Remove"},{"location":"sliceutils/remove/#remove","text":"func Remove[T any](slice []T, i int) []T Remove takes a slice of type T and an index, removing the element at the given index. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } numerals = sliceutils . Remove ( numerals , 3 ) fmt . Print ( numerals ) // [0, 1, 2, 4, 5, 6, 7, 8, 9] }","title":"Remove"},{"location":"sliceutils/reverse/","text":"Reverse func Reverse[T any](slice []T) []T Reverse takes a slice of type T and returns a slice of type T with a reverse order of elements. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } reversed := sliceutils . Reverse ( numerals ) fmt . Print ( reversed ) // [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] }","title":"Reverse"},{"location":"sliceutils/reverse/#reverse","text":"func Reverse[T any](slice []T) []T Reverse takes a slice of type T and returns a slice of type T with a reverse order of elements. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } reversed := sliceutils . Reverse ( numerals ) fmt . Print ( reversed ) // [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] }","title":"Reverse"},{"location":"sliceutils/some/","text":"Some func Some[T any](slice []T, predicate func(value T, index int, slice []T) bool) bool Some takes a slice of type T and a predicate function, returning true if the predicate returned true for some elements. The function is passed the current element, the current index and the slice itself as function arguments. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { friends := [] string { \"John\" , \"Bob\" , \"Mendy\" , \"Suzy\" , \"John\" } result := sliceutils . Some ( friends , func ( value string , index int , slice [] string ) bool { return value == \"Mandy\" }) fmt . Print ( result ) // true }","title":"Some"},{"location":"sliceutils/some/#some","text":"func Some[T any](slice []T, predicate func(value T, index int, slice []T) bool) bool Some takes a slice of type T and a predicate function, returning true if the predicate returned true for some elements. The function is passed the current element, the current index and the slice itself as function arguments. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { friends := [] string { \"John\" , \"Bob\" , \"Mendy\" , \"Suzy\" , \"John\" } result := sliceutils . Some ( friends , func ( value string , index int , slice [] string ) bool { return value == \"Mandy\" }) fmt . Print ( result ) // true }","title":"Some"},{"location":"sliceutils/sum/","text":"Sum func Sum[T numbers](slice []T) (result T) Sum takes a slice of numbers T, which can be any of the number types, and returns a sum of their values. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } result := sliceutils . Sum ( numerals ) fmt . Print ( result ) // 45 }","title":"Sum"},{"location":"sliceutils/sum/#sum","text":"func Sum[T numbers](slice []T) (result T) Sum takes a slice of numbers T, which can be any of the number types, and returns a sum of their values. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } result := sliceutils . Sum ( numerals ) fmt . Print ( result ) // 45 }","title":"Sum"},{"location":"sliceutils/union/","text":"Union func Union[T comparable](slices ...[]T) []T Union takes a variadic number of slices of type T and returns a slice of type T containing the unique elements in the different slices. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { first , second := [] int { 1 , 2 , 3 }, [] int { 1 , 7 , 3 } result := sliceutils . Union ( first , second ) fmt . Print ( result ) // [1, 2, 3, 7] }","title":"Union"},{"location":"sliceutils/union/#union","text":"func Union[T comparable](slices ...[]T) []T Union takes a variadic number of slices of type T and returns a slice of type T containing the unique elements in the different slices. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { first , second := [] int { 1 , 2 , 3 }, [] int { 1 , 7 , 3 } result := sliceutils . Union ( first , second ) fmt . Print ( result ) // [1, 2, 3, 7] }","title":"Union"},{"location":"sliceutils/unique/","text":"Unique func Unique[T comparable](slice []T) []T Unique tales a slice of type T and returns a slice of type T containing all unique elements. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 , 2 , 3 , 3 , 1 } result := sliceutils . Unique ( numerals ) fmt . Print ( result ) // [0, 1, 2, 3] }","title":"Unique"},{"location":"sliceutils/unique/#unique","text":"func Unique[T comparable](slice []T) []T Unique tales a slice of type T and returns a slice of type T containing all unique elements. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/sliceutils\" ) func main () { numerals := [] int { 0 , 1 , 2 , 3 , 3 , 1 } result := sliceutils . Unique ( numerals ) fmt . Print ( result ) // [0, 1, 2, 3] }","title":"Unique"},{"location":"stringutils/stringify/","text":"Stringify func Stringify(value any, opts ...Options) string Stringify receives an arbitrary value and converts it into a string. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/stringutils\" ) func main () { value := 1000 result := stringutils . Stringify ( value ) // \"1000\" fmt . Print ( result ) // \"1000\" } Stringify also accepts an options object with the following properties: NilFormat : the string format for nil values, defaults to \" \". NilMapFormat : the string format for nil map objects, defaults to \"{}\". NilSliceFormat : the string format for nil slice objects, defaults to \"[]\". Base : a number between 2-36 ad the base when converting ints and uints to strings, defaults to Base 10. Precision : number of digits to include when converting floats and complex numbers to strings, defaults to 2. Format : the number notation format, using the stlib FTOA functionalities, defaults to 'f': 'b' (-ddddp\u00b1ddd, a binary exponent), 'e' (-d.dddde\u00b1dd, a decimal exponent), 'E' (-d.ddddE\u00b1dd, a decimal exponent), 'f' (-ddd.dddd, no exponent), 'g' ('e' for large exponents, 'f' otherwise), 'G' ('E' for large exponents, 'f' otherwise), 'x' (-0xd.ddddp\u00b1ddd, a hexadecimal fraction and binary exponent), or 'X' (-0Xd.ddddP\u00b1ddd, a hexadecimal fraction and binary exponent).","title":"Stringify"},{"location":"stringutils/stringify/#stringify","text":"func Stringify(value any, opts ...Options) string Stringify receives an arbitrary value and converts it into a string. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/stringutils\" ) func main () { value := 1000 result := stringutils . Stringify ( value ) // \"1000\" fmt . Print ( result ) // \"1000\" } Stringify also accepts an options object with the following properties: NilFormat : the string format for nil values, defaults to \" \". NilMapFormat : the string format for nil map objects, defaults to \"{}\". NilSliceFormat : the string format for nil slice objects, defaults to \"[]\". Base : a number between 2-36 ad the base when converting ints and uints to strings, defaults to Base 10. Precision : number of digits to include when converting floats and complex numbers to strings, defaults to 2. Format : the number notation format, using the stlib FTOA functionalities, defaults to 'f': 'b' (-ddddp\u00b1ddd, a binary exponent), 'e' (-d.dddde\u00b1dd, a decimal exponent), 'E' (-d.ddddE\u00b1dd, a decimal exponent), 'f' (-ddd.dddd, no exponent), 'g' ('e' for large exponents, 'f' otherwise), 'G' ('E' for large exponents, 'f' otherwise), 'x' (-0xd.ddddp\u00b1ddd, a hexadecimal fraction and binary exponent), or 'X' (-0Xd.ddddP\u00b1ddd, a hexadecimal fraction and binary exponent).","title":"Stringify"},{"location":"structutils/forEach/","text":"ForEach func ForEach[T interface{}](structInstance T, function func(key string, value interface{}, tag reflect.StructTag)) Takes a struct and calls the passed in function for each of its visible fields, passing to in the field's name, value and tag. package main import ( \"fmt\" \"reflect\" \"github.com/Goldziher/go-utils/structutils\" ) type Person struct { FirstName string LastName string Age int `myTag:\"myValue\"` } func main () { personInstance := Person { FirstName : \"Moishe\" , LastName : \"Zuchmir\" , Age : 100 , } structutils . ForEach ( personInstance , func ( key string , value interface {}, tag reflect . StructTag ) { fmt . Printf ( \"%v - %v - %v\\n\" , key , value , tag . Get ( \"myTag\" )) }) // FirstName - Moishe // LastName - Zuchmir // Age - 100 - myValue }","title":"ForEach"},{"location":"structutils/forEach/#foreach","text":"func ForEach[T interface{}](structInstance T, function func(key string, value interface{}, tag reflect.StructTag)) Takes a struct and calls the passed in function for each of its visible fields, passing to in the field's name, value and tag. package main import ( \"fmt\" \"reflect\" \"github.com/Goldziher/go-utils/structutils\" ) type Person struct { FirstName string LastName string Age int `myTag:\"myValue\"` } func main () { personInstance := Person { FirstName : \"Moishe\" , LastName : \"Zuchmir\" , Age : 100 , } structutils . ForEach ( personInstance , func ( key string , value interface {}, tag reflect . StructTag ) { fmt . Printf ( \"%v - %v - %v\\n\" , key , value , tag . Get ( \"myTag\" )) }) // FirstName - Moishe // LastName - Zuchmir // Age - 100 - myValue }","title":"ForEach"},{"location":"structutils/toMap/","text":"ToMap func ToMap[T interface{}](structInstance T, structTags ...string) map[string]any ToMap takes a struct and converts it to into an instance of map[string]any . package main import ( \"fmt\" \"reflect\" \"github.com/Goldziher/go-utils/structutils\" ) type Person struct { FirstName string LastName string Age int `myTag:\"myValue\"` } func main () { personInstance := Person { FirstName : \"Moishe\" , LastName : \"Zuchmir\" , Age : 100 , } personMap := structutils . ToMap ( personInstance ) fmt . Print ( personMap ) // { \"FirstName\": \"Moishe\", \"LastName\": \"Zuchmir\", \"Age\": 100 } } You can also pass in struct tags as an optional argument: package main import ( \"fmt\" \"reflect\" \"github.com/Goldziher/go-utils/structutils\" ) type Person struct { FirstName string LastName string Age int `myTag:\"myValue\"` } func main () { personInstance := Person { FirstName : \"Moishe\" , LastName : \"Zuchmir\" , Age : 100 , } personMap := structutils . ToMap ( personInstance , \"myTag\" ) fmt . Print ( personMap ) // { \"FirstName\": \"Moishe\", \"LastName\": \"Zuchmir\", \"myTag\": 100 } } To omit a value, use the standard \"-\" struct tag value: package main import ( \"fmt\" \"reflect\" \"github.com/Goldziher/go-utils/structutils\" ) type Person struct { FirstName string LastName string Age int `myTag:\"-\"` } func main () { personInstance := Person { FirstName : \"Moishe\" , LastName : \"Zuchmir\" , Age : 100 , } personMap := structutils . ToMap ( personInstance , \"myTag\" ) fmt . Print ( personMap ) // { \"FirstName\": \"Moishe\", \"LastName\": \"Zuchmir\" } }","title":"ToMap"},{"location":"structutils/toMap/#tomap","text":"func ToMap[T interface{}](structInstance T, structTags ...string) map[string]any ToMap takes a struct and converts it to into an instance of map[string]any . package main import ( \"fmt\" \"reflect\" \"github.com/Goldziher/go-utils/structutils\" ) type Person struct { FirstName string LastName string Age int `myTag:\"myValue\"` } func main () { personInstance := Person { FirstName : \"Moishe\" , LastName : \"Zuchmir\" , Age : 100 , } personMap := structutils . ToMap ( personInstance ) fmt . Print ( personMap ) // { \"FirstName\": \"Moishe\", \"LastName\": \"Zuchmir\", \"Age\": 100 } } You can also pass in struct tags as an optional argument: package main import ( \"fmt\" \"reflect\" \"github.com/Goldziher/go-utils/structutils\" ) type Person struct { FirstName string LastName string Age int `myTag:\"myValue\"` } func main () { personInstance := Person { FirstName : \"Moishe\" , LastName : \"Zuchmir\" , Age : 100 , } personMap := structutils . ToMap ( personInstance , \"myTag\" ) fmt . Print ( personMap ) // { \"FirstName\": \"Moishe\", \"LastName\": \"Zuchmir\", \"myTag\": 100 } } To omit a value, use the standard \"-\" struct tag value: package main import ( \"fmt\" \"reflect\" \"github.com/Goldziher/go-utils/structutils\" ) type Person struct { FirstName string LastName string Age int `myTag:\"-\"` } func main () { personInstance := Person { FirstName : \"Moishe\" , LastName : \"Zuchmir\" , Age : 100 , } personMap := structutils . ToMap ( personInstance , \"myTag\" ) fmt . Print ( personMap ) // { \"FirstName\": \"Moishe\", \"LastName\": \"Zuchmir\" } }","title":"ToMap"},{"location":"urlutils/queryStringifyMap/","text":"QueryStringifyMap func QueryStringifyMap[K comparable, V any](values map[K]V) string Creates a query string from a given map instance. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/urlutils\" ) func main () { values := map [ string ] any { \"user\" : \"moishe\" , \"active\" : true , \"age\" : 100 , \"friends\" : [] int { 1 , 2 , 3 , 4 , 5 , 6 }, } result := urlutils . QueryStringifyMap ( values ) fmt . Print ( result ) // \"active=true&age=100&friends=1&friends=2&friends=3&friends=4&friends=5&friends=6&user=moishe\" }","title":"QueryStringifyMap"},{"location":"urlutils/queryStringifyMap/#querystringifymap","text":"func QueryStringifyMap[K comparable, V any](values map[K]V) string Creates a query string from a given map instance. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/urlutils\" ) func main () { values := map [ string ] any { \"user\" : \"moishe\" , \"active\" : true , \"age\" : 100 , \"friends\" : [] int { 1 , 2 , 3 , 4 , 5 , 6 }, } result := urlutils . QueryStringifyMap ( values ) fmt . Print ( result ) // \"active=true&age=100&friends=1&friends=2&friends=3&friends=4&friends=5&friends=6&user=moishe\" }","title":"QueryStringifyMap"},{"location":"urlutils/queryStringifyStruct/","text":"QueryStringifyStruct func QueryStringifyStruct[T interface{}](values T, structTags ...string) string Creates a query string from a given struct instance. Takes struct tag names as optional parameters. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/urlutils\" ) func main () { values := struct { User string Active bool Age int `qs:\"age\"` Friends [] int }{ User : \"moishe\" , Active : true , Age : 100 , Friends : [] int { 1 , 2 , 3 , 4 , 5 , 6 }, } result := urlutils . QueryStringifyStruct ( values , \"qs\" ) fmt . Print ( result ) // \"Active=true&Friends=1&Friends=2&Friends=3&Friends=4&Friends=5&Friends=6&User=moishe&age=100\" } You can pass as many struct tags as you deem necessary, for example the following will also work: package main import ( \"fmt\" \"github.com/Goldziher/go-utils/urlutils\" ) func main () { values := struct { User string Active bool `json:\"active\"` Age int `qs:\"age\"` Friends [] int }{ User : \"moishe\" , Active : true , Age : 100 , Friends : [] int { 1 , 2 , 3 , 4 , 5 , 6 }, } result := urlutils . QueryStringifyStruct ( values , \"json\" , \"qs\" ) fmt . Print ( result ) // \"Friends=1&Friends=2&Friends=3&Friends=4&Friends=5&Friends=6&User=moishe&active=true&age=100\" } If you want to ignore a field, simply use the conventional tag value of \"-\" : package main import ( \"fmt\" \"github.com/Goldziher/go-utils/urlutils\" ) func main () { values := struct { User string Active bool Age int `qs:\"-\"` Friends [] int }{ User : \"moishe\" , Active : true , Age : 100 , Friends : [] int { 1 , 2 , 3 , 4 , 5 , 6 }, } result := urlutils . QueryStringifyStruct ( values , \"qs\" ) fmt . Print ( result ) // \"Active=true&Friends=1&Friends=2&Friends=3&Friends=4&Friends=5&Friends=6&User=moishe\" }","title":"QueryStringifyStruct"},{"location":"urlutils/queryStringifyStruct/#querystringifystruct","text":"func QueryStringifyStruct[T interface{}](values T, structTags ...string) string Creates a query string from a given struct instance. Takes struct tag names as optional parameters. package main import ( \"fmt\" \"github.com/Goldziher/go-utils/urlutils\" ) func main () { values := struct { User string Active bool Age int `qs:\"age\"` Friends [] int }{ User : \"moishe\" , Active : true , Age : 100 , Friends : [] int { 1 , 2 , 3 , 4 , 5 , 6 }, } result := urlutils . QueryStringifyStruct ( values , \"qs\" ) fmt . Print ( result ) // \"Active=true&Friends=1&Friends=2&Friends=3&Friends=4&Friends=5&Friends=6&User=moishe&age=100\" } You can pass as many struct tags as you deem necessary, for example the following will also work: package main import ( \"fmt\" \"github.com/Goldziher/go-utils/urlutils\" ) func main () { values := struct { User string Active bool `json:\"active\"` Age int `qs:\"age\"` Friends [] int }{ User : \"moishe\" , Active : true , Age : 100 , Friends : [] int { 1 , 2 , 3 , 4 , 5 , 6 }, } result := urlutils . QueryStringifyStruct ( values , \"json\" , \"qs\" ) fmt . Print ( result ) // \"Friends=1&Friends=2&Friends=3&Friends=4&Friends=5&Friends=6&User=moishe&active=true&age=100\" } If you want to ignore a field, simply use the conventional tag value of \"-\" : package main import ( \"fmt\" \"github.com/Goldziher/go-utils/urlutils\" ) func main () { values := struct { User string Active bool Age int `qs:\"-\"` Friends [] int }{ User : \"moishe\" , Active : true , Age : 100 , Friends : [] int { 1 , 2 , 3 , 4 , 5 , 6 }, } result := urlutils . QueryStringifyStruct ( values , \"qs\" ) fmt . Print ( result ) // \"Active=true&Friends=1&Friends=2&Friends=3&Friends=4&Friends=5&Friends=6&User=moishe\" }","title":"QueryStringifyStruct"}]}